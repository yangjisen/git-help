### Zset操作
* sorted set操作
* 有序集合
* sorted set 它在set的基础上增加了一个顺序属性, 这一属性在修改添加元素的时候可以指定, 每次指定后, zset会自动从新按新的值调整顺序

##

* 将一个或多个元素插入到集合里面, 默认从尾部开始插入
- 如果要在头部插入, 则找一个元素, 在元素后面添加一个你需要插入的元素即可
```
$redis->zAdd('sorted1', 100, '坑啊', 98.999, 99, 80, 60, 70);
$redis->zAdd('集合', 浮点数(元素),'key', (插入头部的数据), key);
```


* 返回有序集中指定区间内的成员. 成员按分数值递增排序, 分数值相同的则按字典序来排序. 
- 参数：第四个参数表示是否返回各个元素的分数值, 默认为false. 
```
$redis->zRange('sorted', 0, -1, true);
```


* 返回有序集中指定区间内的成员. 成员按分数值递减排序, 分数值相同的则按字典序的倒序来排序. 
``` 
$redis->zReverseRange('sorted', 0, -1, true);
```

* 返回有序集中指定分数区间的成员列表, 按分数值递增排序
``` 
$redis->zRangeByScore('sorted', 10, 99);
```

*自定义返回的序集返回起始位置及条数
``` 
$redis->zRangeByScore('sorted', 0, 90, ['limit' =>[0, 2]]);
```

* 返回有序集中指定分数区间的成员列表, 按分数值递减排序, 分数值相同的则按字典序的倒序来排序. 注意, 区间表示的时候大值在前, 小值在后. 
``` 
$redis->zRevRangeByScore('sorted', 100, 90);
```

* 迭代有序集合中的元素. 
- 可理解为查找指定的值, 将元素修改为float类型
- 返回值：[元素名=>分数值,,..]
```
$redis->zscan('sorted', $it, 100, 10);
```

* 返回指定有序集的元素数量,序集的长度. 
```
$redis->zCard('sorted');
```

* 返回有序集中指定分数区间的成员数量. 
```
$redis->zCount('sorted', 90, 100);
```

* 返回有序集中指定成员的分数值. 若成员不存在则返回false. 
```
$redis->zScore('sorted', 'math');
```

* 返回有序集中指定成员元素的大小排名, 按分数值递增排序. 分数值最小者排名为0. 
```
$redis->zRank('sorted', 60);
```

* 返回有序集中指定成员元素的排名, 按分数值递减排序. 分数值最大者排名为0. 
```
$redis->zRevRank('sorted', 70);
```

* 删除有序集中的一个或多个成员, 忽略不存在的成员. 返回删除的元素个数. 
```
$redis->zRem('sorted', 'chemistry', 'English');
```

* 删除有序集中指定排名区间的所有成员,返回删除元素个数
```
$redis->zRemRangeByRank('sorted', 0, 2);
```

* 删除有序集中指定分数值区间的所有成员, 返回删除元素的个数
```
$redis->zRemRangeByScore('sorted', 80, 90);
```

* 对有序集中指定成员的分数值增加指定增量值. 若为负数则做减法, 若有序集不存在则先创建, 若有序集中没有对应成员则先添加, 最后再操作. 
```
$redis->zIncrBy('sorted', 2, 'Chinese');
```

* 计算给定一个或多个有序集的交集, 元素相加, 并将其存储到目的有序集中
```
$redis->zinterstore('zset3',['sorted','sorted1']);
```


* 计算给定一个或多个有序集的并集, 元素相加, 并将其存储到目的有序集中
```
$redis->zunionstore('zset3',['sorted', 'sorted1']);
```

